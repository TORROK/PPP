CURRENT STATUS
- Birth of new project - wztz
- Networking
  * dynamic localhost detection 
  * external delivery using VirtualCircuit
  * DNS SRV resolution
  * vHost support
  * external vHost support
  * CONTEXT ROUTING
    * necessary routing information
      * local objects ask their root for membership (_request_context_enter with _supplicant)
      * virtual circuits and external vhosts ask room membership
      * root acks membership for _supplicant
        * in general if context advertised beeing public before (specifying TTL or default value (4044 secs))
        * if the context acked it
      * root denies membership 
        * if the context denies it
        * in general
          * if the context denies it in general (either specifying a TTL or default value (4044 secs))
  	  * if the contexts denial TTL is still valid // TODO

FUTURE STATUS
- PSYC
  * API
    * MMP.ReplyGatherer(object)
      ->send(MMP.Packet);
      ->on_reply(function f);
    * MMP.Packet
      ->reply();
      ->on_reply(function f);
    * MMP.Base(server, uniform)
      ->msg(p);
      ->send(p);
      ->ReplyGatherer(void|function f); // factory
      ->enter_context(uniform, function(int(0..2) success:void) callback);
      ->leave_context(uniform);
      
   * switching from public to private _notice_context_private
      * every membership must be rerequested
   * switching from private to public (_notice_context_public optional)
      * all membership information must be discarded
   * API
      * MMP.Base
      _request_context_enter -> general denial
   
- CHANNEL ROUTING
   * context advertises membership (_notice_channel_enter, _notice_channel_leave)
     * routers either add local object to channel or
       * send ad to vhost or virtualcircuit that is the root for _supplicant
       * send ad to all vhosts and virtualcirtuits in context if room is public and broadcast all messages on channel from now on until one
         new node replies


MMP(Or(PSYC(), Polymorphic(...)))
class User {
    object sig = PSYC.MessagePublic();

    void msg(Packet p) {
	PSYC.Message m = sig->decode(p->data);

	if (has_index(this, p->data->type)) {
	    this[p->data->type](p);
	}
    }

    void _notice_enter(Packet p) {
	PSYC.Message m = sig->decode(p->data);
    }
}
polymorphic(([
    _message : Psyc,
    _notice : Psyc,
    _request : Psyc,
    _integer : Int(),
    _string : String(),
    .
    .
    .
    ]);
