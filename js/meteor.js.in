/*
Copyright (C) 2008-2009  Arne Goedeke

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
version 2 as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/
#include "stringbuilder.h"
if( typeof XMLHttpRequest == "undefined" ) XMLHttpRequest = function() {
  try { return new ActiveXObject("Msxml2.XMLHTTP.6.0") } catch(e) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP.3.0") } catch(e) {}
  try { return new ActiveXObject("Msxml2.XMLHTTP") } catch(e) {}
  try { return new ActiveXObject("Microsoft.XMLHTTP") } catch(e) {}
  throw new Error( "This browser does not support XMLHttpRequest." )
};
/**
 * @namespace Meteor js connection namespace.
 */
meteor = new Object();
/**
 * Limit for the incoming buffer. When the incoming XMLHttpRequest object buffer grows larger than this, the connection is reinitiated.
 */
meteor.timer = [];
meteor.lengthes = [];
meteor.counter = 0;
meteor.BUFFER_MAX = 1 << 16; // limit for incoming buffer, exceeding this buffer triggers a reconnect
meteor.KEEPALIVE_TIMEOUT = 40000;
meteor.dismantle = function(xhr) {
	xhr.onreadystatechange = new window.Function;
	xhr.onerror = new window.Function;
	if (xhr.readyState < 4) try { 
	    xhr.abort(); 
	} catch (e) {};
};
meteor.Multiplexer = function(session) {
    this.session = session;
    this.channels = {};
    this.requests = {};
    this.pro_atom = new serialization.AtomParser();
    this.initialized = 0;
    session.callback = UTIL.make_method(this, this.mplexcb);
    this.SuccParser = serialization.generate_structs({
	_channel_success : meteor.ChannelSuccess,
	_channel_fail : meteor.ChannelFail
    });
};
meteor.Multiplexer.prototype = {
    get_new_channel : function(name) {
	if (this.channels[name]) {
	    throw("Channel " + name + " already exists.");
	}

	return this.channels[name] = new meteor.Channel(name, this.session, this);
    },
    get_channel : function(name) {
	return this.channels[name] || this.get_new_channel(name);
    },
    close_channel : function(name) {
	if (this.has_channel(name)) {
	    delete this.channels[name];
	}
    },
    has_channel : function(name) {
	return !!this.channels[name];
    },
    request_channel : function(name, cb) {
	if (this.has_channel(name)) throw("Channel " + name + " already exists.");
	if (this.requests.hasOwnProperty(name)) throw("Channel " + name + " was already requested.");

	this.requests[name] = [ cb, this.get_new_channel(name) ];
    },
    mplexcb : function(atom) {
	//UTIL.log("mplexcb here.");
	var a = this.pro_atom.parse(atom);

	for (var i = 0; i < a.length; i++) {
	  if (a[i].type == "_keepalive") continue;
	  if (!this.initialized) {
	      if (a[i].type == "_multiplex") {
		  this.initialized = 1;
	      } else UTIL.log("%o is not protoplex\n", atom);
	  } else if (a[i].type == "_channel") {
	      var pos = a[i].data.indexOf(" ");
		
	      if (pos == -1) {
		  UTIL.log("malformed channel data: %o", a[i])
		  continue;
	      }

	      var name = a[i].data.substr(0, pos);

	      if (this.has_channel(name)) {
		  this.get_channel(name)._deliver(a[i].data.substr(pos+1));
	      } else UTIL.log("noone cares for channel %o", name||666);
	  } else if (a[i].type === "_multiplex") {
	      for (var name in this.channels) if (this.channels.hasOwnProperty(name)) {
		  this.channels[name].handshake();
	      }
	  } else {
	      var res = this.SuccParser.decode(a[i]);

	      if (res instanceof meteor.ChannelFail) {
		  var chan = this.get_channel(res.name);

		  chan.close("Server denied connection request on channel " + res.name + ": " + res.reason);

		  if (this.requests.hasOwnProperty(res.name)) {
		      var cb = this.requests[res.name][0];
		      delete this.requests[name];

		      try {
			  cb(res.reason, chan);
		      } catch (err) {
			  UTIL.log("Channel(" + res.name + ") accept cb did error on Fail: " + err);
		      }
		  }
	      } else if (res instanceof meteor.ChannelSuccess) {
		  if (this.requests.hasOwnProperty(res.name)) {
		      var cb = this.requests[res.name][0];
		      var chan = this.requests[res.name][1];
		      delete this.requests[res.name];
		      try {
			  cb(0, chan);
		      } catch (err) {
			  UTIL.log("Channel(" + res.name + " accept cb did error: " + err);
		      }
		  }
	      }
	  }
	}
    }
};

meteor.ChannelSuccess = Base.extend({
    _types : {
	name : new serialization.String()
    },
    toString : function() {
	return "meteor.ChannelSuccess(" + this.name + ")";
    }
});
meteor.ChannelFail = Base.extend({
    _types : {
	name : new serialization.String(),
	reason : new serialization.String()
    },
    toString : function() {
	return "meteor.ChannelFail(" + this.name + ", " + this.reason + ")";
    }
});
meteor.ChannelReq = Base.extend({
    constructor : function(name) {
	this.name = name;
    },
    _types : {
	name : new serialization.String()
    }
})

meteor.Channel = function(name, session, multiplexer) {
    this.name = name;
    this.session = session;
    this.multiplexer = multiplexer;
    this.buffer = "";
    this.callback = 0;
    this.errcb = 0;
    this.closed = false;

    this.ReqParser = serialization.generate_structs({
	_channel_request : meteor.ChannelReq,
    });

    //this.session.send("_channel "+ this.name.length + " " + this.name);
    //this.send(""); // handshake / channel open request
    //UTIL.call_later(this.send, this, "");
    //UTIL.call_later(this.session.send, this.session, "_channel " + this.name.length + " " + this.name);
    //this.session.send("_channel " + this.name.length + " " + this.name);
    this.handshake();
};
meteor.Channel.prototype = {
    handshake : function() {
	this.session.send(this.ReqParser.encode(new meteor.ChannelReq(this.name)).render());
    },
    send : function(atom) {
	if (this.closed) throw("Cannot send() in closed channel(" + this.name + ").");
	this.session.send("_channel "+ (atom.length+this.name.length+1) + " " + this.name + " " + atom);
    },
    set_cb : function(cb) {
	if (this.closed) throw("Cannot set_cb() in closed channel(" + this.name + ").");
	this.callback = cb;
    },
    get_cb : function(cb) {
	return this.callback;
    },
    set_onerr : function(onerr) {
	if (this.closed) throw("Cannot set_onerr() in closed channel(" + this.name + ").");
	this.onerr = onerr;
    },
    get_onerr : function() {
	return this.onerr;
    },
    close : function(err) {
	this.closed = true;
	if (this.errcb) this.errcb(err);
	this.multiplexer.close_channel(this.name);
	this.errcb = this.cb = undefined;
	UTIL.log("Channel connection request refused: %o.", err);
    },
    _deliver : function(data) {
	this.buffer += data;
	if (this.callback) {
	    this.callback(this.buffer);
	    this.buffer = "";
	}
    },
};
/**
 * Meteor connection class. This is usually used with Atom serialization on top. Use psyc.Client if unsure.
 * @param {String} url URL of the Meteor connection endpoint.
 * @param {Function} callback Function to be called when data has been received.
 * @param {Function} error Function to be called when a fatal error occurs.
 * @constructor
 * @example
 * var connection;
 * var incoming = function(data) {
 * 	document.write("Received data: " + data);
 * 	connection.send("Hello World.\n");
 * }
 * connection = new meteor.Connection("http://example.org/meteor/", incoming, alert);
 * connection.init();
 */
meteor.Connection = function(url, vars, callback, error) {
    this.url = url;
    this.vars = vars;
    if (!eval("new XMLHttpRequest()").overrideMimeType)
	this.vars.utf8 = "1";
    if (UTIL.App.is_ie) this.vars["autoclose"] = "1";
    this.buffer = "";
    this.callback = callback;
    this.error = error ? error : UTIL.log;
    this.async = true;
    this.pos = 0;
    this.reconnect = 1; // do a reconnect on close
};
meteor.Connection.prototype = {
    reconnect_incoming : function() {
	UTIL.log("reconnecting due to timeout.\n");
	if (this.new_incoming) {
	    meteor.dismantle(this.new_incoming);
	    delete this.new_incoming;
	}
	if (this.incoming) {
	    meteor.dismantle(this.incoming);
	    delete this.incoming;
	}
	this.connect_new_incoming();
    },
    new_incoming_state_change : function(xhr) {
	UTIL.log("new_incoming state is " + xhr.readyState);

	if (xhr.readyState >= 2 && this.new_incoming_timeout) {
	    UTIL.log("clearing new_incoming_timeout");
	    window.clearTimeout(this.new_incoming_timeout);
	    delete this.new_incoming_timeout;
	}
	// we should check here for buffer length. maybe set a max
	// amount to shut down the main one ungracefully
	if (xhr.readyState >= 3) {
	    // TODO: why is this timeout here?
	    window.setTimeout(UTIL.make_method(this, this.connect_incoming, xhr), 100);
	    xhr.onreadystatechange = function() {};
	}
    },
    connect_new_incoming : function() {
	if (this.new_incoming) {
	    // we already have one new incoming and are waiting for the
	    // main one to shut down

	    if (this.new_incoming.readyState == 4) {
		// someone is too fast for us.	
		// TODO: we have to check for data in new_incoming,
		// not sure what to do with it. we can probably savely
		// parse it in case of atoms.
		UTIL.log("New connection already finished.\n");
	    } else return this.connect_incoming();
	}

	//UTIL.log("Connecting new incoming.\n");

	var xhr = eval("new XMLHttpRequest();");
	this.new_incoming = xhr;

	this.vars.random = UTIL.get_random_key(6);
	// this is a bloody hack!
	xhr.open("POST", UTIL.make_url(this.url, this.vars), true);

	// both opera and IE dont handle binary data correctly.
	/*
	    xhr.setRequestHeader("Content-Type", "application/octet-stream");
	}
	*/
	//xhr.overrideMimeType("text/plain; charset=ISO-8859-1");
	if (xhr.overrideMimeType) xhr.overrideMimeType('text/plain; charset=x-user-defined');
	xhr.onreadystatechange = UTIL.make_method(this, this.new_incoming_state_change, xhr);
	var cb = UTIL.make_method(this, function() {
	    UTIL.log("connecting new_incoming timed out. dropping.\n");
	    meteor.dismantle(xhr);
	    delete this.new_incoming;
	    delete this.new_incoming_timeout;
	    this.connect_new_incoming();
	});
	this.new_incoming_timeout = window.setTimeout(cb, meteor.KEEPALIVE_TIMEOUT);
	xhr.send("");
    },
    set_nonblocking : function() {
	this.async = true;
    },
    set_blocking : function() {
	this.async = false;
    },
    incoming_state_change : function(xhr) {
	var s;

	//UTIL.log("incoming state is "+xhr.readyState);

	if (xhr.readyState >= 3) {

	    if (UTIL.App.is_ie && xhr.readyState == 3) {
		return;
	    }

	    if (xhr.status == 200) {
		var length = xhr.responseBody ? xhr.responseBody.length : xhr.responseText.length;

		if (length > this.pos) {
		    //UTIL.log((length-this.pos)+" bytes received in readyState "+xhr.readyState);
		    var str;

		    try {
			if (UTIL.App.is_opera) {
			    str = xhr.responseText.substr(this.pos);
			} else if (xhr.responseBody) {
			    str = xhr.responseBody.slice(this.pos).join("");
			} else {
#					define CHUNK	256
			    var d = new Date();
			    str = xhr.responseText.substr(this.pos);
			    meteor.timer.push(new Date() - d);
			    meteor.lengthes.push([ length, str.length ]);
			    meteor.counter++;
			    
#					if 1
			    var C = new Array(CHUNK), ret, i;
			    var stop = Math.floor(str.length/CHUNK);
			    var rest = str.length & (CHUNK - 1);
			    ret = new Array(stop + (rest ? 1 : 0));
			    var t = -1;

			    for (var j = 0; j < stop; j++) {
				for (i = 0; i < CHUNK; i++) {
				    C[i] = str.charCodeAt(++t) & 0xff;
				}
				ret[j] = String.fromCharCode.apply(String, C);
			    }
			    if (rest) {
				for (i = 0; i < rest; i++) {
				    C[i] = str.charCodeAt(++t) & 0xff;
				}
				ret[ret.length - 1] = String.fromCharCode.apply(String, C.slice(0, rest));
			    }
			    str = ret.join("");
#					endif
			}

			//UTIL.log("calling callback: %o with %db of data", this.callback, str.length);
			UTIL.call_later(this.callback, this, str);
			//this.callback(str);
		    } catch (error) {
			UTIL.log("ERROR: "+error);
		    }

		    this.pos = length;
		}

		//UTIL.log("position %d (max %d)", this.pos, meteor.BUFFER_MAX);

		if (xhr.readyState == 3)// && this.pos < meteor.BUFFER_MAX)
		    return;
	    } else {
		if (xhr.status == 500) {
		    delete this.vars["id"];
		    this.init();
		    return;
		}

		// this throws an exception in firefox. brain
		if (xhr.status) {
		    this.error("HTTP "+xhr.status);
		    return;
		}
	    }

	    meteor.dismantle(xhr);

	    if (this.operatimer) {
		    clearTimeout(this.operatimer);
		    delete this.operatimer;
	    }
	    if (this.reconnect) 
		window.setTimeout(UTIL.make_method(this, this.connect_new_incoming),
				  xhr.status < 99 ? 10000 : 3000);
	}
    },
    incoming_on_error : function() {
	    UTIL.log("INCOMING ERROR!");
	    window.setTimeout(UTIL.make_method(this, this.connect_new_incoming), 500);
    },
    connect_incoming : function(xhr) {
	    if (!xhr) {
		    if (this.new_incoming) {
			    xhr = this.new_incoming;
		    } else throw("you need to call new_incoming() first. no this.new_incoming.");
	    }

	    if (this.incoming) {
		    if (this.incoming.readyState != 4) {
			// we lost some data here. we will still connect the new one because we dont expect it
			// to be closed properly. we need to implement _id in order to fix this properly.
			UTIL.log("Lost data on incoming connection (probably).");
		    }
		    meteor.dismantle(this.incoming);
	    }

	    if (this.operatimer) {
		    clearTimeout(this.operatimer);
		    delete this.operatimer;
	    }

	    xhr.onreadystatechange = UTIL.make_method(this, this.incoming_state_change, xhr);
	    xhr.onerror = UTIL.make_method(this, this.incoming_on_error, xhr);
	    //UTIL.log("moved new incoming to incoming.");
	    delete this.new_incoming;
	    this.incoming = xhr;
	    this.pos = 0;
	    this.incoming_state_change(xhr);

	    // This code polls the xhr for new data in case opera is used. its necessary
	    // because opera does not trigger an event if new data is available in state 3.
	    if (UTIL.App.is_opera) {
		    this.operatimer = setInterval(UTIL.make_method(this, this.incoming_state_change, xhr), 100);
		    //UTIL.log("timer: "+this.operatimer);
	    }
    },
    init_state_change : function(xhr) { // fetch the client_id and go
	    if (xhr.readyState == 4) {
		    if (xhr.status == 200) {
			    var v = new serialization.Vars({ _ : new serialization.String() }).decode(new serialization.AtomParser().parse(xhr.responseText)[0]);
			    v = v.m;
			    this.vars["id"] = v._id;

			    if (this.onconnect) this.onconnect(v);

			    //UTIL.log("got client ID " + this.vars["id"]);
			    meteor.dismantle(xhr);

			    this.connect_new_incoming();
			    if (this.buffer.length) this.send("");
		    } else if (xhr.status < 99) {
			    meteor.dismantle(xhr);
			    window.setTimeout(UTIL.make_method(this, this.init), 10000);
		    } else if (xhr.status == 404) {
			    this.error(xhr.responseText);
		    } else {
			    this.error(xhr.statusText);
		    }
	    }
    },
    /**
     * Initialize the connection. This needs to be called before any data can be sent or received.
     */
    init : function() { // fetch the client_id and go
	    var xhr = eval("new XMLHttpRequest();");
	    this.reconnect = 1;

	    xhr.onreadystatechange = UTIL.make_method(this, this.init_state_change, xhr);
	    this.vars.random = UTIL.get_random_key(6);
	    xhr.open("GET", UTIL.make_url(this.url, this.vars), true);
	    xhr.send("");
    },
    /**
     * Close incoming connection and clean up cyclic references.
     */
    close : function() {
	    var list = [this.new_incoming, this.incoming, this.outgoing];
	    for (var i = 0; i < list.length; i++) {
		    var t = list[i];
		    try {
			    if (t) {
				    meteor.dismantle(t);
			    }
		    } catch(e) { }
	    }
	    delete this.outgoing;
	    delete this.incoming;
	    delete this.new_incoming;
	    delete this.callback;
	    delete this.error;
    },
    /**
     * Send some data.
     * @param {String} data String to be sent.
     */
    send : function(data) {
	    //UTIL.log("sending "+data.length+" bytes");
	    // check for status
	    this.buffer += data;

	    if (this.vars["id"]) { 
		if (!this.async) {
		    this.write();
		} else if (!this.will_write) {
		    this.will_write = true;
		    // we give a small window for more data coming in in the same loop
		    window.setTimeout(UTIL.make_method(this, this.write), 20);
		}
	    }
    },
    outgoing_onerror : function(xhr) {
	    this.will_write = false;
	    this.buffer = this.old_buffer + this.buffer;
	    this.write();
    },
    outgoing_state_change : function(xhr) {
	    //UTIL.log("outgoing state is "+xhr.readyState);

	    if (xhr.readyState == 4) {
		    window.clearTimeout(this.outgoing_timeout);
		    xhr.onreadystatechange = null;
		    if (xhr.status == 200) {
			    // we do this do avoid opening too many connections. this should be enough
			    this.will_write = false;
			    if (this.buffer.length) window.setTimeout(UTIL.make_method(this, this.write), 20);
		    } else  { // this basically means, that the server does not know the id
			    this.error("It seems like the id timed out or something went wrong: "+ xhr.status);
			    delete this.outdoing;
			    meteor.dismantle(xhr);
			    return;
		    }
		    delete this.outdoing;
		    meteor.dismantle(xhr);
	    }
    },
    write : function() {
	    if (this.buffer.length == 0) return;

	    var xhr = eval("new XMLHttpRequest();");
	    this.outgoing = xhr; // we keep it to be able to clean up

	    /*
	    if (this.outgoing) {
		    // we could reuse the xhr object, however this
		    // is not completely safe on safari/chrome
		    // TODO: do it for firefox, opera, ie
		    meteor.dismantle(this.outgoing);
	    }
	    */

	    this.vars.random = UTIL.get_random_key(6);
	    xhr.open("POST", UTIL.make_url(this.url, this.vars), this.async);
	    // we do this charset hackery because we have internal utf8 and plain ascii
	    // for the rest of atom. this is supposed to be a binary transport
	    if (this.async) {
		//UTIL.log("doing async request. setting callbacks");
		xhr.onreadystatechange = UTIL.make_method(this, this.outgoing_state_change, xhr);
		xhr.onerror = UTIL.make_method(this, this.outgoing_onerror, xhr);
		var cb = UTIL.make_method(this, function() {
		    meteor.dismantle(xhr);
		    delete this.outgoing;
		    this.will_write = false;
		    this.buffer = this.old_buffer + this.buffer;
		    this.write();
		});
		this.outgoing_timeout = window.setTimeout(cb, 3000);
	    }// else UTIL.log("doing sync request.");

	    //UTIL.log("outgoing state change is %o", xhr.onreadystatechange);
	    if (xhr.sendAsBinary) {
		    xhr.setRequestHeader("Content-Type", "application/octet-stream");
		    xhr.setRequestHeader("Content-Length", this.buffer.length);
		    xhr.sendAsBinary(this.buffer);
	    } else {
		    xhr.send(this.buffer);   
	    }
	    //UTIL.log("writing "+this.buffer.length+" bytes\n");
	    this.old_buffer = this.buffer;
	    this.buffer = "";
    },
    set_cb : function(cb) {
	 this.callback = cb;
    },
    get_cb : function() {
	return this.callback;
    },
    set_onerr : function(error) {
	this.error = error;
    },
    get_onerr : function() {
	return this.error;
    }
};
// the params handed by the user could be prototyped with a
// msg and something more
meteor.CallbackWrapper = function(params, mapping) {
	this.mapping = mapping;
	this.params = params;	
};
meteor.CallbackWrapper.prototype = {
	msg : function(p, message) {
		var ok = true;
		if ((this.params.source && this.params.source != p.source())
		||  (this.params.context && this.params.context != p.v("_context"))
		||  (this.params.target && this.params.target != p.target())
		) {
			ok = false;
			//UTIL.log(p.toString()+" is not the one.\n");
		}

		if (ok) {
			if (this.params.object) {
				if (this.params.cb) {
					return this.params.cb.call(this.params.object, p, message, this);
				}

				return this.params.object.msg(p, message, this);
			} else {
				return this.params.cb(p, message, this);
			}
		}
	},
	active : function() {
		return this.mapping == 0 ? 0 : 1;
	},
	unregister : function() {
		if (this.mapping == 0) return;

		var list = this.mapping.get(this.params.method);

		for (var i = 0; i < list.length; i++) {
			if (list[i] == this) {
				list.splice(i, 1);
			}
		}

		this.mapping = 0;
	}
};

meteor.Auth = Base.extend({
    _types : {
	hmac : new serialization.String(),
	token : new serialization.String(),
	expiry : new serialization.Integer()
    }
});
meteor.Success = Base.extend({
    toString : function() {
	return "meteor.Success()";
    }
});
meteor.Fail = Base.extend({
    _types : {
	reason : new serialization.String()
    },
    toString : function() {
	return "meteor.Fail(" + (this.reason || "") + ")";
    }
});

meteor.Locked = Base.extend({
    constructor : function(channel, authProvider, cb) {
	this.channel = channel;
	this.authProvider = authProvider;
	this.cb = cb;
	this.parser = new serialization.AtomParser();
	this.channel.callback = UTIL.make_method(this, this._incoming);
	this.AuthInfo = serialization.generate_structs({
	    _auth : meteor.Auth
	});
	this.FailInfo = serialization.generate_structs({
	    _success : meteor.Success,
	    _fail : meteor.Fail
	});
    },
    _incoming : function(atom) {
	var result, succ, l;

	console.log("Locked::incoming(%o)", Array.prototype.slice.call(arguments));

	l = this.parser.parse(atom);

	for (var i = 0; i < l.length; i++) {
	    console.log("           --> %o", l[i]);
	    result = this.FailInfo.decode(l[i]);
	    console.log("                     --> %o", result);

	    if (result instanceof meteor.Success) {
		succ = 1;
	    }
	}

	if (l.length) {
	    if (succ) {
		this.channel.callback = undefined;
		UTIL.call_later(this.cb, null, this.channel);
		return;
	    }

	    this.authProvider(this);
	}
    },
    test : function() {
	var auth = new meteor.Auth();

	auth.hmac = "The HMAC";
	auth.token = "The token";
	auth.expiry = 14;
	this.channel.send(this.AuthInfo.encode(auth).render());
    },
    auth : function(token, secret, expiry) {
	var hmac = new HMAC(UTIL.SHA256.Hash).get(secret).hmac([token, expiry].join(","));

	this.auth_hmac(token, hmac, expiry);
    },
    auth_hmac : function(token, hmac, expiry) {
	var data = new meteor.Auth();

	data.hmac = hmac;
	data.token = token;
	data.expiry = expiry;
	this.channel.send(this.AuthInfo.encode(data).render());
    }
});
